---
title: "Calculating Plot Canopy Heights "
author: "Glenn Slade"
date: "29/11/2022"
output: html_document
---



##  Canopy Height Calculations for Plots

```{r include = FALSE, warning = FALSE}
# Lidr processing of point cloud - DTM Generation and Heigth above ground calculation

library(lidR)
library(sp)
library(terra)
library(lubridate)
library(RColorBrewer)
library(ggplot2)
library(MASS)
library(splines)
library(rgeos)
library(tidyverse)
library(viridis)
library(gridExtra)
library(DescTools)
library(sf)
library(exactextractr)
library(writexl) 
library (raster)
library(dplyr)
library(remotes)
library(cowplot)
library(reshape2)
library(readxl)
library(tictoc)
library(gstat)

```

## Read in las file for survey and plot DTM produced from previous scripts

```{r}
# load in sample area
#P1_clip <- vect("E:/Glenn/Reproducibility/Plot/P1.shp")

P1_sf <- read_sf(dsn = "E:/Glenn/Reproducibility/Plot", layer = "P1")
P45_sf <- read_sf(dsn = "E:/Glenn/Reproducibility/Plot", layer = "P45")


#Read P1 and P45 las files from survey 1 
#
#S1_P1_las = readLAS( "E:/Glenn/Reproducibility/Processed/LAS/Plots/S1_P1.las")
S1_P45_las = readLAS("E:/Glenn/Reproducibility/Processed/LAS/Plots/S1_P45a.laz")
S1_P45_las_w = readLAS("E:/Glenn/Reproducibility/Processed/LAS/Plots/S1_P45_w.laz")

#Read in all plot DTMs generated by TIN in previous script
All_DTM = rast("E:/Glenn/Reproducibility/Plot/All_dtm_1cm.tif" )


```

## Calculate Heigth Above ground (HAG) - referred to as Normalised height in LidR

In LidR this is a simple subtraction of the ground height DTM (calculated in a previous script using TIN method and GNSS plot corners and additional GNSS site wide ground height data ) from the point cloud .las file to produce a normalised las (nlas). Unfortunately Rmarkdown doesnt plot las files...

```{r, warning = FALSE}
nlas <- S1_P45_las  - All_DTM
plot(nlas, size = 1, bg = "grey")


```


## Rasterise point cloud - Max height in 0.01 m raster grid cell

In LidR as a basic function this is done through the rasterise_canopy and point to raster function (p2r)

```{r, warning = FALSE}
chm <- rasterize_canopy(nlas, res = .01, algorithm = p2r())
col <- height.colors(25)
plot(chm, col = col)

writeRaster(chm,"E:/Glenn/Reproducibility/Plot/P45a_chm.tif" , overwrite = TRUE)
```

## Now need to interpolate heights for points with no data

The primary aim for this step needs to be preserving the point cloud data whilst filling in empty cells with interpolated values.
In the LidR documentation there are two ways to approach this - either the raster product is processed to fill empty cells using a terra function or an interpolation algorithm is used in the initial rasterize_canopy function.
Below is the script for the standard focal method recommended in Lidr documentation 
7x7 window used in Terra to fill in values in empty cells in the raster product


```{r, warning = FALSE}
fill.na <- function(x, i=5) { if (is.na(x)[i]) { return(mean(x, na.rm = TRUE)) } else { return(x[i]) }}
w <- matrix(1, 7, 7)
filled <- terra::focal(chm, w, fun = fill.na)
plot(filled, col = col)


```

This appears to do a good job at empty cell filling - 
But this method at present appears to be changing existing height values - see this difference image - white areas are the empty cells, coloured areas the difference between the interpolate height raster and the original rasterised point cloud (ignoring the empty cells) 

```{r, warning = FALSE}

diff1 <- filled -chm
plot(diff1, col = col)

```

In Cunliff et al 2021 a 7x7 array (power of 1) was used with IDW. 

In Terra there doesnt appear to be a simple way to implement IDW but you would need 
to construct a custom weighting matrix.  Below is a 3x3 
but I am not sure on how to set up the weighting matrix - 


```{r, warning = FALSE}


w <- matrix(c(0,.25,0,.25,0,.25,0,.25,0), 3, 3)
filled_IDW2 <- terra::focal(chm, w, na.rm=TRUE, NAonly=TRUE)
plot(filled_IDW2, col = col)



```

and this doesnt look quite right. 
Again - It should only be acting on empty cells but appears to be changing values


```{r, warning = FALSE}
diff3 <- filled_IDW2 -chm
plot(diff3, col=col)

```


## An alternative is to use the rasterise_canopy function with the LIdR TIN algorithm to interpolate points when sampling the point cloud .

In LidR there are a number of point to raster algorithms which interpolate points and attempt to fill in the holes - the best is a TIN algortithm

```{r, warning = FALSE}
chmtin <- rasterize_canopy(nlas, res = 0.01, algorithm = dsmtin())
plot(chmtin, col = col)

writeRaster(chmtin,"E:/Glenn/Reproducibility/Plot/P45a_chmtin.tif", overwrite = TRUE )
```

The TIN appears to have the least impact of the methods on existing values in the point cloud but still appears to be changing some values compared to the original uninterpolated raster product

```{r, warning = FALSE}


diff2 <- chmtin -chm
plot(diff2, col = col)

```

To avoid edge effects in TIN an alternative is to perform the LIDR Rasterisation and TIN function
on a larger area and then clip to resulting image to the plot size afterwards

```{r, warning = FALSE}

nlas_w <- S1_P45_las_w  - All_DTM
#plot(nlas_w, size = 1, bg = "grey")

chmtin_w <- rasterize_canopy(nlas_w, res = 0.01, algorithm = dsmtin())
plot(chmtin_w, col = col)

writeRaster(chmtin_w,"E:/Glenn/Reproducibility/Plot/P45_chmtin_w.tif", overwrite = TRUE )


aoi_terra <- vect(P45_sf)


ras_crop <- crop(chmtin_w, aoi_terra)
plot (ras_crop)
ras_mask <- mask(ras_crop, aoi_terra)

plot(ras_mask)

diff3 <- ras_mask -chm
plot(diff3, col = col)

diff4 <- ras_mask -chmtin
plot(diff4, col = col)

```
